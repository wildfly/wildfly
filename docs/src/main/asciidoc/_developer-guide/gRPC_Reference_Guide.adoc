[[gRPC_Reference_Guide]]
= gRPC Reference Guide

ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:important-caption: :heavy_exclamation_mark:
:caution-caption: :fire:
:warning-caption: :warning:
endif::[]

https://grpc.io/[*gRPC*] is a _Remote Procedure Call_ framework defined and supported by Google.
It is notable for a number of benefits:

* It is based on a language neutral _Interface Definition Language_ (_IDL_) that supports numerous
programming languages, including, of course, Java.

* It has a compact wire format and runs over HTTP/2, leading to fast transmission.

The WildFly `*grpc*` subsystem supports exposing one or more gRPC services to gRPC clients.

*Note.* The examples referred to here are found in the 
https://github.com/wildfly-extras/wildfly-grpc-feature-pack/tree/main/examples[WildFly gRPC examples].

== Interface Definition Language

The basic IDL comes from the https://developers.google.com/protocol-buffers[*protobuf*] project, also supported by Google.
Basic IDL supports the definition of message types; for example

```
syntax = "proto3";

option java_multiple_files = true;
option java_package = "org.wildfly.extension.grpc.example.helloworld";
option java_outer_classname = "HelloWorldProto";

// The request message containing the user's name.
message HelloRequest {
  string name = 1;
}

// The response message containing the greetings
message HelloReply {
  string message = 1;
}
```
is a simplified version of
https://github.com/wildfly-extras/wildfly-grpc-feature-pack/blob/main/examples/helloworld/proto/src/main/proto/helloworld.proto[helloworld.proto].
The message types `HelloRequest` and `HelloReply` each have a single field with builtin type `string`. Note that
each field in a message is associated with an integer, which helps with translation to and from the wire format and
also helps with versioning. For each supported language, there is a compiler for translating the IDL file.

gRPC contributes a compiler plugin that supports remote procedure call definitions. For example, the following
definition also comes from
https://github.com/wildfly-extras/wildfly-grpc-feature-pack/blob/main/examples/helloworld/proto/src/main/proto/helloworld.proto[helloworld.proto]:

```
// The greeting service definition.
service Greeter {
  // Sends a greeting
  rpc SayHello (HelloRequest) returns (HelloReply);
}
```
Here, `SayHello` is the name of the method, `HelloRequest` is the type of argument, and `HelloReply`
is the type of the return value.

*Note.* An alternative syntax for rpc definitions uses `{}` instead of `;`.
```
  rpc SayHello (HelloRequest) returns (HelloReply) {}
```
They have the same meaning, except that `{}` can be used to pass values to plugins.

== Compiler output

For a given target language, the protobuf compiler plus the gRPC plugin generate code from the IDL file 
for use on the server and client side. Consider `org.wildfly.extension.grpc.example.helloworld.HelloRequest`, 
generated in `target/generated-sources/protobuf/java/` from
https://github.com/wildfly-extras/wildfly-grpc-feature-pack/tree/main/examples/helloworld/client/
by the protobuf compiler. `org.wildfly.extension.grpc.example.helloworld.GreeterClient` in 
https://github.com/wildfly-extras/wildfly-grpc-feature-pack/tree/main/examples/helloworld/client uses
it to create an instance of `HelloRequest`:

[source,java]
----
HelloRequest request = HelloRequest.newBuilder().setName(name).build();
----

Also, consider `org.wildfly.extension.grpc.example.helloworld.GreeterGrpc` generated by the compiler in
`target/generated-sources/protobuf/grpc-java` from
https://github.com/wildfly-extras/wildfly-grpc-feature-pack/tree/main/examples/helloworld/service/.
The internal class `GreeterImplBase` has method

[source,java]
----
public void sayHello(org.wildfly.extension.grpc.example.helloworld.HelloRequest request,
        io.grpc.stub.StreamObserver<org.wildfly.extension.grpc.example.helloworld.HelloReply> responseObserver);
----

which is derived from the rpc `sayHello` definition. This method will throw an exception. The point is that
`GreeterImplBase` is meant to be overridden with useful code. For example,
`org.wildfly.extension.grpc.example.helloworld.GreeterServiceImpl.sayHello()`
in https://github.com/wildfly-extras/wildfly-grpc-feature-pack/tree/main/examples/helloworld/service
takes a name and returns a greeting:

[source,java]
----
public class GreeterServiceImpl extends GreeterGrpc.GreeterImplBase {

    @Override
    public void sayHello(HelloRequest request, StreamObserver<HelloReply> responseObserver) {
        String name = request.getName();
        String message = "Hello " + name;
        responseObserver.onNext(HelloReply.newBuilder().setMessage(message).build());
        responseObserver.onCompleted();
    }
}
----

`GreeterServiceImpl` is a gRPC service which is meant to be installed in a gRPC server, which looks something like this:

[source,java]
----
io.grpc.Server server = ServerBuilder.forPort(9555)
                            .addService(new GreeterServiceImpl())
                            .build()
                            .start();
----

The `Server` listens on port 9555 and dispatches an incoming message to the appropriate service.

`GreeterGrpc` also has inner class `GreeterBlockingStub` for use on the client side. Consider class
`org.wildfly.extension.grpc.example.helloworld.GreeterClient` in
https://github.com/wildfly-extras/wildfly-grpc-feature-pack/tree/main/examples/helloworld/client/.
[Note. The code from `GreeterClient` is somewhat modified here for simplicity.] It creates a `GreeterBlockingStub`

[source,java]
----
ManagedChannel channel = ManagedChannelBuilder.forTarget("localhost:9555")
                             .usePlaintext()
                             .build();
GreeterBlockingStub blockingStub = GreeterGrpc.newBlockingStub(channel);
----

and uses it to send a message to the server:

[source,java]
----
HelloRequest request = HelloRequest.newBuilder().setName(name).build();
HelloReply response = blockingStub.sayHello(request);
logger.debug("Greeting: " + response.getMessage());
----

== WildFly `grpc` subsystem

The WildFly subsystem `grpc` allows WildFly to expose multiple gRPC services, where a
gRPC service is a class that implements `io.grpc.BindableService`. See, for example, the inner class
`GreeterGrpc.GreeterImplBase`, which is subclassed by
`org.wildfly.extension.grpc.example.helloworld.GreeterServiceImpl`. The `grpc` subsystem registers all
gRPC services discovered in available deployments.

The `grpc` subsystem may be configured by the following parameters. Most of the following descriptions
are derived from the javadoc on the setter methods in io.grpc.

* `*flow-control-window*`: Sets the flow control window in bytes. Setting `flow-control-window` disables auto flow control
   tuning; use `initial-flow-control-window` to enable auto flow control tuning. If not
   called, the default value is 1024 * 1024 with auto flow control tuning. The type is `int` and the unit is seconds.

* `*handshake-timeout*`:  Sets the permitted time for new connections to complete negotiation handshakes before being
   killed.  The default value is 2 minutes. The type is `long` and the unit is seconds. 
   
* `*initial-flow-control-window*`: Sets the initial flow control window in bytes. Setting `initial-flow-control-window` enables auto
   flow control tuning using bandwidth-delay product algorithm. To disable auto flow control
   tuning, use `flow-control-window`. By default, auto flow control is enabled with
   initial flow control window size of 1024 * 1024. The type is `int` and the unit is seconds.
   
* `*keep-alive-time*`: Sets a custom keepalive time, the delay time for sending next keepalive ping. An unreasonably
   small value might be increased, and `Long.MAX_VALUE` seconds or an unreasonably
   large value will disable keepalive. The default is two hours. The type is `long` and the unit is seconds.

* `*keep-alive-timeout*`: Sets a custom keepalive timeout, the timeout for keepalive ping requests. An unreasonably small
   value might be increased. The default is 20 seconds. The type is `long` and the unit is seconds.

* `*key-manager-name*`: Refers to a key manager defined in the `elytron` subsystem. The type is `String`, and no key manager is
   set by default.

* `*max-concurrent-calls-per-connection*`: The maximum number of concurrent calls permitted for each incoming connection. Defaults to no
   limit. The type is `int`.
   
* `*max-connection-age*`: Sets a custom max connection age; a connection lasting longer than which will be gracefully
   terminated. An unreasonably small value might be increased.  A random jitter of +/-10% will be
   added to it. `Long.MAX_VALUE` seconds or an unreasonably large value will disable
   max connection age. The type is `long` and the unit is seconds. The default value disables max connection age.
   
* `*max-connection-age-grace*`: Sets a custom grace time for the graceful connection termination. Once the max connection age
   is reached, RPCs have the grace time to complete. RPCs that do not complete in time will be
   cancelled, allowing the connection to terminate. `Long.MAX_VALUE` seconds or an
   unreasonably large value are considered infinite. The type is `long` and the unit is seconds. The default value is
   essentially infinite.
   
* `*max-connection-idle*`: Sets a custom max connection idle time; connections being idle for longer than which will be
   gracefully terminated. Idleness duration is defined since the most recent time the number of
   outstanding RPCs became zero or the connection establishment. An unreasonably small value might
   be increased. `Long.MAX_VALUE` seconds or an unreasonably large value will disable max connection idle.
   The type is `long` and the unit is seconds. The default value is essentially infinite.
   
* `*max-inbound-message-size*`: Sets the maximum message size allowed to be received on the server. If not set,
   defaults to 4 MiB. The default provides protection to servers who haven't considered the
   possibility of receiving large messages while trying to be large enough to not be hit in normal
   usage. The default is 4 * 1024 * 1024. The type is `int`.

* `*max-inbound-metadata-size*`: Sets the maximum size of metadata allowed to be received. This is cumulative size of the
   entries with some overhead, as defined for http://httpwg.org/specs/rfc7540.html#rfc.section.6.5.2
   HTTP/2's SETTINGS_MAX_HEADER_LIST_SIZE. The default is 8 KiB. The type is `int`.

* `*permit-keep-alive-time*`: Specify the most aggressive keep-alive time clients are permitted to configure. The server will
   try to detect clients exceeding this rate and when detected will forcefully close the
   connection. The default is 5 minutes. The type is `long` and the unit is seconds. *Note.* Even though a default is
   defined that allows some keep-alives, clients must not use
   keep-alive without approval from the service owner. Otherwise, they may experience failures in
   the future if the service becomes more restrictive. When unthrottled, keep-alives can cause a
   significant amount of traffic and CPU usage, so clients and servers should be conservative in
   what they use and accept.

* `*permit-keep-alive-without-calls*`: Sets whether to allow clients to send keep-alive HTTP/2 PINGs even if there are no outstanding
   RPCs on the connection. The type is `boolean`, and the default is false.

* `*protocol-provider*`: Sets the `SslContext` implementation to use. The type is `String`. The default is
   OPENSSL if it is available. Otherwise, the default is JDK.

* `*server-host*`: The host to which the server is to be bound. The type is `String`, and the default is "localhost".

* `*server-port*`: The port to which the server is to be bound. The type is `int` and the default is 9555.

* `*session-cache-size*`: Set the size of the cache used for storing SSL session objects. The type is `long` and the
   default depends on the `SslContext` implementation.

* `*session-timeout*`: Set the timeout for the cached SSL session objects, in seconds. The type is `long` and the
   default depends on the `SslContext` implementation.

* `*shutdown-timeout*`: Sets the time that the server should wait to become terminated, giving up if the timeout
   is reached. The type is `int`, and the default is 3 seconds.

* `*ssl-context-name*`: Refers to an SSL Context defined in the `elytron` subsystem. The type is `String` and no value
   is set by default.
  
* `*start-tls*`: Sets whether the first write request shouldn't be encrypted. The type is `boolean` and the default
   depends on the `SslContext` implementation.
   
* `*trust-manager-name*`: Refers to a trust manager defined in the `elytron` subsystem. The type is `String`. No trust manager
   is set by default.
   
== Security

The `grpc` subsystem mainly depends on the
xref:../WildFly_Elytron_Security.adoc[`elytron`] subsystem
for SSL/TLS configuration. For example, the parameter `key-manager-name`
is used to retrieve a key manager from the `elytron` subsystem. If gRPC communication is meant to take place over SSL/TLS connections,
then `key-manager-name` is required. Conversely, if non-secure connections are desired, then `key-manager-name` must be
set to "" or null. By default, `key-manager-name` is set to null; i.e., the default
connection uses plaintext.

The parameter `ssl-context-name` refers to an SSL context configured in the `elytron` subystem. If `ssl-context-name` is not null,
then the SSL context can be used to supply the following additional values:

* enabled cipher suites
* enabled protocols, e.g., "TLSv1.2"
* SSL context provider

If set, the `protocol-provider` parameter overrides the value retrieved from the SSL context. The default value of 
`ssl-context-name` is null.

The parameter `trust-manager-name` refers to a trust manager configured in the `elytron` subsystem, which is necessary only if
client identities are meant to be verified. By default it is set to null.

The parameters `session-cache-size`, `session-timeout`, and `start-tls` also apply to SSL/TLS connections.

Suppose you have a keystore `server.keystore.jks` and a truststore `server.truststore.jks` in
standalone/configuration. Then you want something like the following, extracted from the definition
of the the `elytron` subsystem in
ssl/standalone.xml.twoway, which is used by the helloworld and chat examples:

```
<tls>
     <key-stores>
         <key-store name="key-store-afcdd1f8-d1a7-4137-aa13-c45237e32428">
             <credential-reference clear-text="secret"/>
             <implementation type="JKS"/>
             <file required="false" path="server.keystore.jks" relative-to="jboss.server.config.dir"/>
         </key-store>
         <key-store name="trust-store-eeeecd12-36f9-4156-92c7-a889383f17a1">
             <credential-reference clear-text="secret"/>
             <implementation type="JKS"/>
             <file required="false" path="server.truststore.jks" relative-to="jboss.server.config.dir"/>
         </key-store>
     </key-stores>
     <key-managers>
         <key-manager name="key-manager-afcdd1f8-d1a7-4137-aa13-c45237e32428" key-store="key-store-afcdd1f8-d1a7-4137-aa13-c45237e32428">
             <credential-reference clear-text="secret"/>
         </key-manager>
     </key-managers>
     <trust-managers>
         <trust-manager name="key-manager-trust-store-eeeecd12-36f9-4156-92c7-a889383f17a1" key-store="trust-store-eeeecd12-36f9-4156-92c7-a889383f17a1"/>
     </trust-managers>
</tls>
```
Given those definitions, you can configure the `grpc` subsystem as follows:
```
<subsystem xmlns="urn:wildfly:grpc:1.0"
    key-manager-name="key-manager-afcdd1f8-d1a7-4137-aa13-c45237e32428"
    trust-manager-name="key-manager-trust-store-eeeecd12-36f9-4156-92c7-a889383f17a1"/>

```
This sets up the server for connections in which identities are checked on both the server and client sides.

Now, on the client side, take a look at `GreeterClient` in the helloworld example:
[source,java]
----
if ("none".equals(ssl)) {
    channel = ManagedChannelBuilder.forTarget(target).usePlaintext().build();
} else if ("oneway".equals(ssl)) {
    InputStream trustStore = classLoader.getResourceAsStream("client.truststore.pem");
    ChannelCredentials creds = TlsChannelCredentials.newBuilder().trustManager(trustStore).build();
    channel = Grpc.newChannelBuilderForAddress("localhost", 9555, creds).build();
} else if ("twoway".equals(ssl)) {
    InputStream trustStore = classLoader.getResourceAsStream("client.truststore.pem");
    InputStream keyStore = classLoader.getResourceAsStream("client.keystore.pem");
    InputStream key = classLoader.getResourceAsStream("client.key.pem");
    ChannelCredentials creds = TlsChannelCredentials.newBuilder().trustManager(trustStore).keyManager(keyStore, key).build();
    channel = Grpc.newChannelBuilderForAddress("localhost", 9555, creds).build();
} 
----
Here, `client.truststore.pem`, `client.keystore.pem`, and `client.key.pem` are in the src/main/resources/ directory.
Note that, unlike the server runtime, the client expects keystores in pem format.

== Server interceptors

gRPC implementations in some languages, including Java, support a server interceptor concept. (There
is also a client interceptor concept, but that is not relevant here.) As per usual, gRPC server interceptors wrap
a call for some cross-cutting purpose. Here is an example in which an `io.grpc.ServerInterceptor` 
intercepts and modifies the input message before the service implementation executes:

[source,java]
----
public class TestServerInterceptor1 implements ServerInterceptor {

    @Override
    public <ReqT, RespT> ServerCall.Listener<ReqT> interceptCall(
            ServerCall<ReqT, RespT> call,
            final Metadata requestHeaders,
            ServerCallHandler<ReqT, RespT> next) {

        ServerCall.Listener<ReqT> listener = next.startCall(call, requestHeaders);
        return new TestListener<ReqT>(listener);
    }

    static class TestListener<ReqT> extends SimpleForwardingServerCallListener<ReqT> {

        protected TestListener(ServerCall.Listener<ReqT> delegate) {
            super(delegate);
        }

        @Override
        public void onMessage(ReqT message) {
            HelloRequest request = (HelloRequest) message;
            messages.HelloRequest.Builder builder = messages.HelloRequest.newBuilder();
            @SuppressWarnings("unchecked")
            ReqT reqT = (ReqT) builder.setName("!!" + request.getName()).build();
            delegate().onMessage(reqT);
        }
    }
}
----
Here is a `ServerInterceptor` that adds another response header after the wrapped
service implementation executes:

[source,java]
----
public class StreamingServerInterceptor1 implements ServerInterceptor {

    static final Metadata.Key<String> CUSTOM_HEADER_KEY =
            Metadata.Key.of("custom_server_header_key", Metadata.ASCII_STRING_MARSHALLER);
    
    @Override
    public <ReqT, RespT> ServerCall.Listener<ReqT> interceptCall(
            ServerCall<ReqT, RespT> call,
            final Metadata requestHeaders,
            ServerCallHandler<ReqT, RespT> next) {

        return next.startCall(
                new SimpleForwardingServerCall<ReqT, RespT>(call) {

                    @Override
                    public void sendHeaders(Metadata responseHeaders) {
                        responseHeaders.put(CUSTOM_HEADER_KEY, "WHAAAT?");
                        super.sendHeaders(responseHeaders);
                    }
                }, requestHeaders);
    }
}
----
For more information, see https://grpc.io/docs/guides/interceptors/[gRPC Interceptor Guide].

There are some issues that arise in the WildFly context that are not addressed in
the general case supported by the Java implementation.
The expectation, in general, is that the management of the
gRPC server, including registering services and interceptors, is under the control
of the application. In WildFly, on the other hand, the server is managed by the `grpc`
subsystem. Whenever a WAR with a gRPC service is detected, the `grpc` subsystem 
extracts all of the method implementations and interceptors and registers them with
the runtime. In the standard treatment, all methods would be wrapped by all interceptors,
which makes no sense in WildFly. The `grpc` subsystem manages the registration so
that all methods discovered in a WAR are wrapped only by all interceptors discovered
in *the same WAR*.

Another issue that arises in WildFly is the order of interceptor execution. In the
usual case, the application registers the interceptors in the desired order. In the `grpc` subsystem environment, there has to be another way of ordering
the interceptors, and the use of the `jakarta.annotation.Priority` annotation is 
adopted. On the way into the service method, interceptors with lower `@Priority` values 
run before interceptors with higher `@Priority` values, and after the service
method they run after interceptors with higher `@Priority` values.
