/*
 * Copyright The WildFly Authors
 * SPDX-License-Identifier: Apache-2.0
 */

package org.wildfly.extension.jakarta.data;

import static org.jboss.as.weld.Capabilities.WELD_CAPABILITY_NAME;
import static org.wildfly.extension.jakarta.data._private.JakartaDataLogger.ROOT_LOGGER;

import java.security.AccessController;
import java.security.PrivilegedActionException;
import java.security.PrivilegedExceptionAction;
import java.util.ServiceLoader;
import java.util.Set;
import java.util.function.Function;

import jakarta.data.repository.Repository;
import jakarta.enterprise.context.spi.CreationalContext;
import jakarta.enterprise.event.Observes;
import jakarta.enterprise.inject.spi.AnnotatedField;
import jakarta.enterprise.inject.spi.AnnotatedType;
import jakarta.enterprise.inject.spi.Extension;
import jakarta.enterprise.inject.spi.InjectionPoint;
import jakarta.enterprise.inject.spi.InjectionTarget;
import jakarta.enterprise.inject.spi.ProcessInjectionTarget;
import jakarta.persistence.EntityManagerFactory;
import jakarta.persistence.PersistenceUnit;
import org.hibernate.StatelessSession;
import org.jboss.as.controller.capability.CapabilityServiceSupport;
import org.jboss.as.jpa.container.PersistenceUnitSearch;
import org.jboss.as.jpa.container.StatelessSessionSupplierImpl;
import org.jboss.as.server.deployment.Attachments;
import org.jboss.as.server.deployment.DeploymentPhaseContext;
import org.jboss.as.server.deployment.DeploymentUnit;
import org.jboss.as.server.deployment.DeploymentUnitProcessingException;
import org.jboss.as.server.deployment.DeploymentUnitProcessor;
import org.jboss.as.weld.WeldCapability;
import org.jipijapa.plugin.spi.PersistenceUnitMetadata;
import org.jipijapa.plugin.spi.ScopedStatelessSessionSupplier;
import org.jipijapa.plugin.spi.StatelessSessionFactory;

public class JakartaDataDeploymentProcessor implements DeploymentUnitProcessor {

    @Override
    public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {

        DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();

        ROOT_LOGGER.debugf("JakartaDataDeploymentProcessor.deploy for %s", deploymentUnit);

        if (deploymentUnit.getParent() != null) {
            return;
        }

        try {
            CapabilityServiceSupport support = deploymentUnit.getAttachment(Attachments.CAPABILITY_SERVICE_SUPPORT);

            final WeldCapability weldCapability = support.getCapabilityRuntimeAPI(WELD_CAPABILITY_NAME, WeldCapability.class);
            if (!weldCapability.isPartOfWeldDeployment(deploymentUnit)) {
                ROOT_LOGGER.noCdiDeployment();
            } else {
                weldCapability.registerExtensionInstance(new JakartaDataCDIExtension(deploymentUnit), deploymentUnit);
                ROOT_LOGGER.debugf("Added JakartaDataCDIExtension to %s", deploymentUnit);
            }
        } catch (CapabilityServiceSupport.NoSuchCapabilityException e) {
            //We should not be here since the subsystem depends on weld capability. Just in case ...
            ROOT_LOGGER.deploymentRequiresCapability(deploymentUnit.getName(), WELD_CAPABILITY_NAME);
        }
    }

    private static class JakartaDataCDIExtension implements Extension {

        private final DeploymentUnit deploymentUnit;

        private JakartaDataCDIExtension(DeploymentUnit deploymentUnit) {
            this.deploymentUnit = deploymentUnit;
        }

        /**
         * This is an integration very much tied to Repository implementations generated
         * by the existing Hibernate Data Repository implementations. It limits itself
         * to targets that:
         * <ol>
         *     <li>implement interfaces annotated with {@link Repository @Repository}
         *         (which should only be ones generated by Hibernate Data Repository, as that's what we support)</li>
         *     <li>have a field annotated with {@link PersistenceUnit @PersistenceUnit}</li>
         *     <li>have a field of type {@link StatelessSession}</li>
         *     <li>implement a {@code @PostConstruct} method</li>
         * </ol>
         * <p/>
         * It replaces the value of the StatelessSession field with an instance of TransactionScopedStatelessSession.
         * <p/>
         * The expectation is that in the future WildFly will provide a mechanism Hibernate Data Repositories can use
         * to explicitly configure the injection of something like TransactionScopedStatelessSession. This integration
         * is meant to cover existing code (and new code created until the replacement mechanism is in place.)
         *
         * @param event the observed event
         * @param <T> the type of the injection target
         */
        public <T> void observeInjectionTarget(@Observes ProcessInjectionTarget<T> event) {
            if (isJakartaDataComponent(event.getAnnotatedType())) {
                event.setInjectionTarget(new JakartaDataInjectionTarget<>(deploymentUnit, event.getInjectionTarget(), event.getAnnotatedType()));
                ROOT_LOGGER.debugf("Wrapped the InjectionTarget for Jakarta Data component %s", event.getAnnotatedType());
            }
        }

        private static <T> boolean isJakartaDataComponent(AnnotatedType<T> annotatedType) {
            for (Class<?> iface : annotatedType.getJavaClass().getInterfaces()) {
                if (isRepositoryInterface(iface)) {
                    return true;
                }
            }
            return false;
        }

        private static boolean isRepositoryInterface(Class<?> clazz) {

            if (clazz.isInterface() && clazz.getAnnotation(Repository.class) != null) {
                return true;
            }

            for (Class<?> superIface : clazz.getInterfaces()) {
                if (isRepositoryInterface(superIface)) {
                    return true;
                }
            }

            Class<?> parent = clazz.getSuperclass();
            return parent != null && !Object.class.equals(parent) && isRepositoryInterface(parent);
        }
    }

    private static class JakartaDataInjectionTarget<T> implements InjectionTarget<T> {

        private final DeploymentUnit deploymentUnit;
        private final InjectionTarget<T> delegate;
        private final AnnotatedType<T> annotatedType;
        private final StatelessSessionFactory<?> statelessSessionFactory;

        JakartaDataInjectionTarget(DeploymentUnit deploymentUnit, InjectionTarget<T> toWrap, AnnotatedType<T> annotatedType) {
            this.deploymentUnit = deploymentUnit;
            this.delegate = toWrap;
            this.annotatedType = annotatedType;
            this.statelessSessionFactory = ServiceLoader.load(StatelessSessionFactory.class, getClass().getClassLoader())
                                                .findFirst().orElseThrow(IllegalStateException::new);
        }

        @Override
        public void inject(T instance, CreationalContext<T> ctx) {
            delegate.inject(instance, ctx);
        }

        @Override
        public void postConstruct(T instance) {
            ROOT_LOGGER.debugf("Processing postConstruct for %s", instance);

            // The @PostConstruct method that Hibernate Data Repositories generates updates the value
            // of the 'session' field. So wait until this done before we insert the object we want.

            delegate.postConstruct(instance);

            // See if instance has the fields we are looking for; if so replace the value of the session field.

            AnnotatedField<? super T> emfField = null;
            AnnotatedField<? super T> sessionField = null;
            String scopedPuName = null;

            for (AnnotatedField<? super T> annotatedField : annotatedType.getFields())  {

                if (StatelessSession.class.equals(annotatedField.getJavaMember().getType())) {
                    sessionField = annotatedField;
                } else {
                    PersistenceUnit puAnnotation = annotatedField.getAnnotation(PersistenceUnit.class);
                    if (puAnnotation != null) {
                        scopedPuName = getScopedPUName(puAnnotation.unitName());
                        emfField = annotatedField;
                    }
                }

                if (emfField != null && sessionField != null) {
                    break;
                }
            }

            if (emfField != null && sessionField != null) {
                if (System.getSecurityManager() == null) {
                    replaceSession(instance, emfField, sessionField, scopedPuName);
                } else {
                    final AnnotatedField<? super T> ef = emfField;
                    AnnotatedField<? super T> sf = sessionField;
                    String pun = scopedPuName;
                    try {
                        AccessController.doPrivileged(new PrivilegedExceptionAction<Void>() {
                            @Override
                            public Void run() {
                                replaceSession(instance, ef, sf, pun);
                                return null;
                            }
                        });
                    } catch (PrivilegedActionException e) {
                        Exception cause = e.getException();
                        if (cause instanceof RuntimeException runtime) {
                            throw runtime;
                        }
                        throw new RuntimeException(cause);
                    }
                }
            } else {
                // This can be fine; e.g. the repository implementation is from newer version of Hibernate Data Repositories
                ROOT_LOGGER.debugf("AnnotatedType %s did not have expected fields. emf=%s, session=%s", annotatedType, emfField, sessionField);
            }
        }

        private void replaceSession(T instance ,AnnotatedField<? super T> emfField,
                                           AnnotatedField<? super T> sessionField, String scopedPuName) {

            try {
                // We have a Repository implementation instance that matches what we're looking for.
                // Replace the value of the session field with a TransactionScopedStatelessSession
                emfField.getJavaMember().setAccessible(true);
                EntityManagerFactory emf = (EntityManagerFactory) emfField.getJavaMember().get(instance);
                sessionField.getJavaMember().setAccessible(true);
                Object session = createSession(emf, scopedPuName);
                sessionField.getJavaMember().set(instance, session);
            } catch (IllegalAccessException e) {
                throw new RuntimeException(e);
            }
        }

        private AutoCloseable createSession(EntityManagerFactory emf, String scopedPuName) {
            Function<Function<EntityManagerFactory, AutoCloseable>, ScopedStatelessSessionSupplier> function =
                    input -> new StatelessSessionSupplierImpl(emf, input, scopedPuName);
            return statelessSessionFactory.getTransactionScopedSession(function);
        }

        @Override
        public void preDestroy(T instance) {
            delegate.preDestroy(instance);
        }

        @Override
        public T produce(CreationalContext<T> ctx) {
            return delegate.produce(ctx);
        }

        @Override
        public void dispose(T instance) {
            delegate.dispose(instance);
        }

        @Override
        public Set<InjectionPoint> getInjectionPoints() {
            return delegate.getInjectionPoints();
        }

        private String getScopedPUName(final String persistenceUnitName) {
            PersistenceUnitMetadata scopedPu = PersistenceUnitSearch.resolvePersistenceUnitSupplier(deploymentUnit, persistenceUnitName);
            assert  scopedPu != null; // if it were inject would have failed
            return scopedPu.getScopedPersistenceUnitName();
        }
    }
}
